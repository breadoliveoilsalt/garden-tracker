class Garden < ActiveRecord::Base

  validates :name, presence: true
  validates :square_feet, numericality: {only_integer: true, message: "must be a whole number"}, allow_nil: true
  validates :user_id, presence: true, numericality: {only_integer: true}

  belongs_to :user
  has_many :species_garden
  has_many :species, through: :species_garden
  has_many :plantings

  accepts_nested_attributes_for :plantings
  # They probably want me to use something like this if the quantity is blank:
    #  accepts_nested_attributes_for :tags, reject_if: proc { |attributes| attributes['name'].blank? }
    # from rails-blog-nested-forms (mine)

  def plantings_attributes=(planting_attributes_hash)

      # When creating a new garden and mass assignment jumps to this method,
      # the garden (parent of planting) has to be saved first or else there
      # will be an error when trying to create the associated planting in this method.
      # In other words, even though this is triggered by Garden.create, the garden
      # instance is not saved yet with an id, and so we need to save it here to create the
      # child planting:

    if self.save

        # Need to specify ".values" because, thanks to the has_nested_attributes_for
        # macro, the format looks like [plantings_attributes][0][hash_of_attributes].
        # So .values is used to run just the hash_of_attributes through the methods below:
      planting_attributes_hash.values.each do | planting_attributes |

          # First, check if we are creating a new garden and creating a new planting with it.
          # This will be the case if the user has filled in something for [:quantity]
          # and the planting does not have an [:id] yet because the planting has not been persisted:
        if planting_attributes[:quantity] != "" && !planting_attributes[:id]
          planting = self.plantings.build(planting_attributes)
          planting.save
          planting.garden.species << planting.species

          # Second, check if we are editing a planting.  This will be the case if the plantings
          # has an [:id] that was passed into params by rails (in an autogenerated hidden field):
        elsif planting_attributes[:id]
          planting = Planting.find_by(id: planting_attributes[:id])
          planting.update(planting_attributes)

            # Tried to see if there was a way to get any errors in planting to pass on
            # to the updated garden, as it does when a new garden is created with planting
            # errors.  This did not work, however:
          if planting.errors.details != {}
              self.errors.details.merge!(planting.errors.details)
          end

          # planting.update(planting_attributes)
          # binding.pry # I can see errors in planting here with line above


          #planting.save  # did not appear to trigger error messages either

        end
      end
    end
  end



end
